
AtCoder Programming Guide for beginners

参照

昨日の続き
無駄なコピーを減らす
関数に引数を渡す場合、無駄なコピーが発生することがあります。

    #include <bits/stdc++.h>
    using namespace std;
    
    // 配列の先頭100要素の値の合計を計算する
    int sum100(vector<int> a) {
      int result = 0;
      for (int i = 0; i < 100; i++) {
        result += a.at(i);
      }
      return result;
    }
    
    int main() {
      vector<int> vec(10000000, 1);  // すべての要素が1の配列
    
      // sum100 を500回呼び出す
      for (int i = 0; i < 500; i++) {
        cout << sum100(vec) << endl;  // 配列のコピーが生じる
      }
    }

実行結果

    100
    100
    100
    100
    100
    (省略)
    ...

実行時間
7813 ms
※一例なので異なる結果になることがあります。
上のプログラムでは関数`sum100`を呼び出すたびに配列の要素がコピーされるので、1000万要素の配列のコピーが500回生じています。
この実行結果では全体で7秒以上の時間がかかっていて、配列を1回コピーするのに約15ミリ秒(0.015秒)程かかっていることになります。

1000万?
要素数1000万の配列として定義されているから
sum100関数を呼び出すためにわざわざ要素数をコピーしているのか
1000万の先頭100しかアクセスしない関数なのに、全部配列をコピーして処理しているということ
それを500回やってるので無駄が多い

ここで、引数の`vector<int> a`を`vector<int> &a`として参照渡しするように変更します。

    #include <bits/stdc++.h>
    using namespace std;
    
    // 配列の先頭100要素の値の合計を計算する (参照渡し)
    int sum100(vector<int> &a) {
      int result = 0;
      for (int i = 0; i < 100; i++) {
        result += a.at(i);
      }
      return result;
    }
    
    int main() {
      vector<int> vec(10000000, 1);  // すべての要素が1の配列
    
      // sum100 を500回呼び出す
      for (int i = 0; i < 500; i++) {
        cout << sum100(vec) << endl;  // 参照渡しなので配列のコピーは生じない
      }
    }

実行結果

    100
    100
    100
    100
    100
    (省略)
    ...

実行時間
15 ms
※一例なので異なる結果になることがあります。
こちらのプログラムでは、配列を参照渡ししているので呼び出し時に配列の要素がコピーされず、 実行時間が約15ミリ秒に収まっています。
値渡しを用いた`sum100`では1回あたりの呼び出しに約15ミリ秒かかっていたことを踏まえれば、 約500倍程高速に動作するようになったことになります。
これらのサンプルプログラムはあまりない意味の無い極端な例ですが、現実的なプログラムでも、 複数回呼び出される関数で配列の値渡しを行うと上の例のように実行時間が遅くなってしまうことがあります。
詳しくは2.06.計算量で扱いますが、プログラムを高速化したい場合には配列のコピーについて特に気をつける必要があります。 コピーが必要のない場合は参照渡しを用いるのが良いでしょう。

「配列を参照渡ししているので呼び出し時に配列の要素がコピーされず」
とあるがコピーされないのならどうやって値にアクセスしてるのだろうか
コピーせずアクセスするということは配列の値そのものへアクセスして配列そのものの状態に対して処理を行うということか
抽象的だがイメージが湧いてきた
恐らく値渡しは毎度メモリに値や配列をコピーしているが、参照渡しは参照している「範囲」のみに対して処理を行うものか
いったいどこにコピーしているのだろうか　これじゃブラックボックスだ
ブラックボックスばかりでは言葉にするのはとてもむずかしい
メモリの状態を基準にして理解したい･･･


参照先を変更することはできない
一度宣言した参照の参照先を後から変更することもできません。

これは要注意

一番苦手な再帰関数をこれから学ぶ


- 「ある関数の中で同じ関数を呼び出す」ことを再帰呼び出しという

始めのキーポイントの頭にこの説明がある
もうここから意味がわからない

繰り返し処理を行う方法として、これまでforループやwhileループのようなループ構文を扱ってきました。
再帰も繰り返し処理を行う方法の一つです。
再帰とは「ある関数の中で同じ関数を呼び出す」ことです。また、このような関数のことを再帰関数といいます。

関数の中で同じ関数を呼び出す
そのままの字面で覚えるしかない


    #include <bits/stdc++.h>
    using namespace std;
    
    int sum(int n) {
      if (n == 0) {
        return 0;
      }
    
      // sum関数の中でsum関数を呼び出している
      int s = sum(n - 1);
      return s + n;
    }
    
    int main() {
      cout << sum(2) << endl;    // 0 + 1 + 2 = 3
      cout << sum(3) << endl;    // 0 + 1 + 2 + 3 = 6
      cout << sum(10) << endl;   // 0 + 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 = 55
    }

再帰関数を学んでる途中だが自分の学習方法が先日まとめたように、憶測と推測で理解を保管してしまっておりこれまでの学んだことがまったく信用できなくなっている

なのでソフトウェア開発を学ぶにあたり、学ぶべき正しい情報が体系的にまとめられていて正しいかどうかの信頼性も担保されている情報はどこにあるのか考えた結果大学の情報工学部のシラバスを参考にすれば良いのではないかと考えた

そこで実際に参考にしたのはこちら
http://www.ocw.titech.ac.jp/index.php?module=General&action=T0200&GakubuCD=4&GakkaCD=342300&KeiCD=23&tab=2&LeftTab=

体系的になりそうな要素を抜き出してみる
手続き型プログラミング基礎 
キーワード
手続き型プログラミング、データ型、標準入出力、制御構造、配列、関数、ファイル入出力、再帰、整列、探索、アルゴリズム、データ解析

C言語のデータ型、標準入出力、演算子、制御構造、関数、再帰、配列、ファイル入出力、文字列

関連する科目

- CSC.T253 ： 手続き型プログラミング発展
- CSC.T263 ： 関数型プログラミング基礎
- CSC.T273 ： オブジェクト指向プログラミング
- CSC.T271 ： データ構造とアルゴリズム
- CSC.T344 ： システムプログラミング
- CSC.T354 ： 並列プログラミング
- CSC.T362 ： 数値計算法

こういう繋がりが知りたかった
独学では断片的かつ独立した情報のみが散乱しておりどう繋がりがあるのか素人ではまったく見当がつかない

自分はなにが知りたいのだろうか
ここがはっきりしない

そもそもソフトウェア開発してお金がほしいがゴールだったはず
お金がもらえることを基準としたソフトウェア開発ができるような情報を集めればいいはず

とりあえず情報工学シラバスを元につながりのある要素を数珠つなぎとしてまとめていく

まとめた情報をもとに今後の学習の指針として扱う

手続き型、オブジェクト指向型、関数型のもろもろのプログラミングの概念、データ構造とアルゴリズム、コンピュータネットワーク、OS、コンパイラ、コンピュータアーキテクチャ

だいたいコンピュータを学ぶ基礎としてはまとまったと思う

再帰関数の学習が終われば次は基礎のひとつとしてOSを学んでいきたい


